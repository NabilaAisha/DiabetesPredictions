# -*- coding: utf-8 -*-
"""Diabetes Prediction Analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16phJO2O2uTLmsRK03xpRog4dRDsyUahN

#Overview

## A. Business Understanding

## B. Data Understanding
"""

from google.colab import files
uploaded = files.upload()

import io
import pandas as pd

data = pd.read_excel(io.BytesIO(uploaded['diabetes_prediction_dataset.xlsx']))

"""## C. Data Preparation

### 1. Exploratory Data Analysis (EDA)

#### 1.1 Feature Checking
"""

titles = ['diabetes']
datasets = [data]

numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']

numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
features_check = pd.DataFrame({}, )
features_check['datasets'] = titles

features_check['numeric_features'] = [len((df.select_dtypes(include = numerics)).columns) for df in datasets]
features_check['numerical_features_name'] = [', '.join(list((df.select_dtypes(include = numerics)).columns)) for df in datasets]
features_check['categorical_features'] = [len((df.select_dtypes(include = 'object')).columns) for df in datasets]
features_check['categorical_features_name'] = [', '.join(list((df.select_dtypes(include = 'object')).columns)) for df in datasets]
features_check['boolean_features'] = [len((df.select_dtypes(include = 'bool')).columns) for df in datasets]
features_check['boolean_features_name'] = [', '.join(list((df.select_dtypes(include = 'bool')).columns)) for df in datasets]
features_check['total_columns'] = [len(df.columns) for df in datasets]
features_check['total_rows'] = [len(df) for df in datasets]
features_check.style.background_gradient(cmap = 'Blues')

"""#### 1.2 Missing values checking"""

missing_check = pd.DataFrame({}, )
missing_check['datasets'] = titles
missing_check['features'] = [', '.join([col for col, null in df.isnull().sum().items()]) for df in datasets]
missing_check['null_amount'] = [df.isnull().sum().sum() for df in datasets]
missing_check['null_features_amount'] = [len([col for col, null in df.isnull().sum().items() if null > 0]) for df in datasets]
missing_check['null_features'] = [', '.join([col for col, null in df.isnull().sum().items() if null > 0]) for df in datasets]
missing_check.style.background_gradient(cmap='Blues')

"""#### 1.3 Data Visualizations by automated EDA"""

!pip install dataprep
from dataprep.eda import create_report

create_report(data).show()

"""### 2. Data Preprocessing

#### 2.1 Feature Engineering
"""

# Change categorical to numeric
from sklearn.preprocessing import LabelEncoder

dataset = ['hypertension', 'heart_disease', 'diabetes', 'gender', 'smoking_history']
for col in dataset:
    le = LabelEncoder()
    data[col] = le.fit_transform(data[col])

data.head()

# Handle categorical variables
df = pd.get_dummies(data, columns=['gender', 'smoking_history','hypertension','heart_disease'])

df.head()

"""## D. Modelling to predict diabetes by RBFNN"""

from sklearn.model_selection import train_test_split
# Split the data
X = df.drop('diabetes', axis=1)
y = df['diabetes']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from sklearn.neural_network import MLPClassifier

rbfnn_model = MLPClassifier(hidden_layer_sizes=(10,), activation='logistic', max_iter=1000, random_state=42)
rbfnn_model.fit(X_train, y_train)

y_prob = rbfnn_model.predict_proba(X_test)
threshold = 0.5
y_pred_binary = (y_prob[:, 1] > threshold).astype(int)

print("Binary Predictions:")
print(y_pred_binary)

accuracy = accuracy_score(y_test, y_pred_binary)
print(f'Accuracy: {accuracy}')

print(classification_report(y_test, y_pred_binary))

import matplotlib.pyplot as plt
import numpy as np

# Assuming y_test is the true labels and y_pred_binary is the predicted labels

# Count the number of correct predictions
correct_predictions = np.sum(y_test.values == y_pred_binary)

# Count the number of incorrect predictions
incorrect_predictions = len(y_test) - correct_predictions

# Plot the bar chart
labels = ['Correct Predictions', 'Incorrect Predictions']
values = [correct_predictions, incorrect_predictions]

plt.bar(labels, values, color=['green', 'red'])
plt.title('Correct vs Incorrect Predictions')
plt.ylabel('Number of Samples')

# Add labels to each bar
for i in range(len(labels)):
    plt.text(i, values[i] + 0.1, str(values[i]), ha='center', va='bottom')

plt.show()